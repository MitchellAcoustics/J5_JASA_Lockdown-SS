if (!require("pacman")) install.packages("pacman")
pacman::p_load(knitr, ModelMetrics, gridExtra, ggplot2, glue)
train.pred <- train.data[grp]
train.pred$actual <- train.data[target][[1]]
train.pred$pred <- predict(model)
test.pred <- test.data[grp]
test.pred$actual <- test.data[target][[1]]
test.pred$pred <- predict(model, newdata=test.data)
# Calculate the normalised RMSE
# range <- abs(max(train.pred$actual) - min(train.pred$actual))
train.mae <- MAE(train.pred$pred, train.pred$actual)
test.mae <- MAE(test.pred$pred, test.pred$actual)
# Plot predicted vs actual
test.title <- glue("Test Set (MAE=", round(test.mae, 3), ")", sep="")
test.plot <- ggplot(test.pred, aes(x=pred, y=actual, colour=LocationID)) +
geom_point() +
geom_abline(intercept=0, slope=1) +
labs(x = 'Predicted Values', y='Actual Values', title=test.title)+
coord_fixed() +
theme(legend.position="none")
train.title <- glue("Train Set (MAE=", round(train.mae, 3), ")", sep="")
train.plot <- ggplot(train.pred, aes(x=pred, y=actual, colour=LocationID)) +
geom_point() +
geom_abline(intercept=0, slope=1) +
labs(x = 'Predicted Values', y='Actual Values', title=train.title) +
coord_fixed() +
theme(legend.position="none")
grid.arrange(train.plot, test.plot, nrow=1)
results <- list("train.pred" = train.pred, "test.pred" = test.pred, "test.mae" = test.mae, "train.mae" = train.mae)
}
Pleasant.results <- model.building(target="ISOPleasant", features = features, train = train, test = test, grp="LocationID", exclude.features = c("LAeq"))
knitr::opts_chunk$set(echo = TRUE)
init_features <- c("Loudness_N5(soneGF)", "Sharpness_S(acum)", "Rough_HM_R(asper)", "I_HM_I(iu)", "FS_(vacil)", "LAeq_L(A)(dB(SPL))", "LA10_LA90(dB(SPL))", "LCeq_LAeq(dB(SPL))", "SIL3_Avg,arith(dB(SPL))", "SpectralCentroid(Hz)", "PeakSpectralCentroid(Hz)")
init_feature_string <- paste(init_features, collapse = " + ")
init_feature_string
library(glue)
library(tidyr)
library(here)
library(knitr)
library(dplyr)
library(readxl)
data <- read_excel(here("data", "2021-05-05", "SSID Europe Database V1.0.xlsx"), sheet = "Master Merge")
data <- as_tibble(data)
data <- data[c("GroupID", "LocationID", "Lockdown", "ISOPleasant", "ISOEventful", "Human", "Traffic", "Natural", init_features)]
data <- rename(data, "N5" = "Loudness_N5(soneGF)")
data <- rename(data, "S" = "Sharpness_S(acum)")
data <- rename(data, "R" = "Rough_HM_R(asper)")
data <- rename(data, "I" = "I_HM_I(iu)")
data <- rename(data, "FS" = "FS_(vacil)")
data <- rename(data, "LAeq" = "LAeq_L(A)(dB(SPL))")
data <- rename(data, "LA10_LA90" = "LA10_LA90(dB(SPL))")
data <- rename(data, "LCeq_LAeq" = "LCeq_LAeq(dB(SPL))")
data <- rename(data, "SIL3" = "SIL3_Avg,arith(dB(SPL))")
features <- c("N5", "S", "R", "I", "FS", "LAeq", "LA10_LA90", "LCeq_LAeq", "SIL3")
feature_string <- paste(features, collapse = " + ")
feature_string
locations <- c("CamdenTown", "EustonTap", "MarchmontGarden", "MonumentoGaribaldi", "PancrasLock", "RegentsParkFields", "RegentsParkJapan", "RussellSq", "SanMarco", "StPaulsCross", "StPaulsRow", "TateModern", "TorringtonSq")
data <- data %>%
filter(LocationID %in% locations)
print("Full data table has dimensions: ")
print(dim(data))
kable(print(head(data)))
data <- data %>% mutate_at(vars(GroupID, LocationID, Lockdown), funs(as.factor))
data <- data %>% mutate_at(vars(c("ISOPleasant", "ISOEventful", "Traffic", "Human", "Natural", features)), funs(as.numeric))
kable(head(data))
prelockdownData <- data %>% filter(Lockdown == 1)
lockdownData <- data %>% filter(Lockdown == 2)
prelockdownData <- drop_na(prelockdownData)
# prelockdownData[c(features)] <- scale(prelockdownData[c(features)])
# Train-test split
library(groupdata2)
set.seed(42)
parts = partition(prelockdownData, p=0.2, cat_col="LocationID")
train = parts[[2]]
test = parts[[1]]
kable(summary(train))
kable(summary(test))
model.building <- function(target, features, train, test, grp="LocationID", exclude.features = NULL, print.step.summ = FALSE, scale=TRUE, ...) {
if (!require("pacman")) install.packages("pacman")
pacman::p_load(lmerTest, glue, knitr, car, sjPlot, MuMIn, ggplot2, gridExtra, ModelMetrics)
# Remove the excluded features from the feature vector
if (length(exclude.features)>=1) {
features <- grep(paste0(exclude.features, collapse = "|"), features, invert=TRUE, value=TRUE)
}
features.string <- paste(features, collapse = " + ")
formula <- as.formula(glue(target, " ~ 1 + ", features.string, " + (1 + ", features.string, "|", grp, ")"))
train.data <- train
test.data <- test
if (scale) {
train.data[c(features)] <- scale(train.data[c(features)])
}
# Fit initial model and run stepwise feature selection
init.model <- lmer(formula, data=train.data)
step.model <- step(init.model, data=train.data, reduce.random=TRUE)
scaled.model <- get_model(step.model)
formula <- formula(scaled.model)
model <- lmer(formula, data=train)
if (print.step.summ) {
print(step.model$fixed)
print(step.model$random)
print(summary(model))
}
# kable(vif(model))
# print(tab_model(model, show.icc=TRUE, collapse.ci=TRUE, show.aic=TRUE))
print(plot_model(model, type="re", title=glue("Random effects - ", target), show.values=TRUE))
print(plot_model(model, show.values=TRUE))
print(r.squaredGLMM(model))
# Generating predictions and evaluating for training and test set
pred.results <- pred.plots(model, target, train.data, test.data, grp=grp)
results <- list("step.results" = step.model, "model" = model, "pred.results"= pred.results, "scaled.model"=scaled.model)
}
pred.plots <- function(model, target, train.data, test.data, grp="LocationID") {
if (!require("pacman")) install.packages("pacman")
pacman::p_load(knitr, ModelMetrics, gridExtra, ggplot2, glue)
train.pred <- train.data[grp]
train.pred$actual <- train.data[target][[1]]
train.pred$pred <- predict(model)
test.pred <- test.data[grp]
test.pred$actual <- test.data[target][[1]]
test.pred$pred <- predict(model, newdata=test.data)
# Calculate the normalised RMSE
# range <- abs(max(train.pred$actual) - min(train.pred$actual))
train.mae <- MAE(train.pred$pred, train.pred$actual)
test.mae <- MAE(test.pred$pred, test.pred$actual)
# Plot predicted vs actual
test.title <- glue("Test Set (MAE=", round(test.mae, 3), ")", sep="")
test.plot <- ggplot(test.pred, aes(x=pred, y=actual, colour=LocationID)) +
geom_point() +
geom_abline(intercept=0, slope=1) +
labs(x = 'Predicted Values', y='Actual Values', title=test.title)+
coord_fixed() +
theme(legend.position="none")
train.title <- glue("Train Set (MAE=", round(train.mae, 3), ")", sep="")
train.plot <- ggplot(train.pred, aes(x=pred, y=actual, colour=LocationID)) +
geom_point() +
geom_abline(intercept=0, slope=1) +
labs(x = 'Predicted Values', y='Actual Values', title=train.title) +
coord_fixed() +
theme(legend.position="none")
grid.arrange(train.plot, test.plot, nrow=1)
results <- list("train.pred" = train.pred, "test.pred" = test.pred, "test.mae" = test.mae, "train.mae" = train.mae)
}
Pleasant.results <- model.building(target="ISOPleasant", features = features, train = train, test = test, grp="LocationID")
knitr::opts_chunk$set(echo = TRUE)
init_features <- c("Loudness_N5(soneGF)", "Sharpness_S(acum)", "Rough_HM_R(asper)", "I_HM_I(iu)", "FS_(vacil)", "LAeq_L(A)(dB(SPL))", "LA10_LA90(dB(SPL))", "LCeq_LAeq(dB(SPL))", "SIL3_Avg,arith(dB(SPL))", "SpectralCentroid(Hz)", "PeakSpectralCentroid(Hz)")
init_feature_string <- paste(init_features, collapse = " + ")
init_feature_string
library(glue)
library(tidyr)
library(here)
library(knitr)
library(dplyr)
library(readxl)
data <- read_excel(here("data", "2021-05-05", "SSID Europe Database V1.0.xlsx"), sheet = "Master Merge")
data <- as_tibble(data)
data <- data[c("GroupID", "LocationID", "Lockdown", "ISOPleasant", "ISOEventful", "Human", "Traffic", "Natural", init_features)]
data <- rename(data, "N5" = "Loudness_N5(soneGF)")
data <- rename(data, "S" = "Sharpness_S(acum)")
data <- rename(data, "R" = "Rough_HM_R(asper)")
data <- rename(data, "I" = "I_HM_I(iu)")
data <- rename(data, "FS" = "FS_(vacil)")
data <- rename(data, "LAeq" = "LAeq_L(A)(dB(SPL))")
data <- rename(data, "LA10_LA90" = "LA10_LA90(dB(SPL))")
data <- rename(data, "LCeq_LAeq" = "LCeq_LAeq(dB(SPL))")
data <- rename(data, "SIL3" = "SIL3_Avg,arith(dB(SPL))")
features <- c("N5", "S", "R", "I", "FS", "LAeq", "LA10_LA90", "LCeq_LAeq", "SIL3")
feature_string <- paste(features, collapse = " + ")
feature_string
locations <- c("CamdenTown", "EustonTap", "MarchmontGarden", "MonumentoGaribaldi", "PancrasLock", "RegentsParkFields", "RegentsParkJapan", "RussellSq", "SanMarco", "StPaulsCross", "StPaulsRow", "TateModern", "TorringtonSq")
data <- data %>%
filter(LocationID %in% locations)
print("Full data table has dimensions: ")
print(dim(data))
kable(print(head(data)))
data <- data %>% mutate_at(vars(GroupID, LocationID, Lockdown), funs(as.factor))
data <- data %>% mutate_at(vars(c("ISOPleasant", "ISOEventful", "Traffic", "Human", "Natural", features)), funs(as.numeric))
kable(head(data))
prelockdownData <- data %>% filter(Lockdown == 1)
lockdownData <- data %>% filter(Lockdown == 2)
prelockdownData <- drop_na(prelockdownData)
# prelockdownData[c(features)] <- scale(prelockdownData[c(features)])
# Train-test split
library(groupdata2)
set.seed(42)
parts = partition(prelockdownData, p=0.2, cat_col="LocationID")
train = parts[[2]]
test = parts[[1]]
kable(summary(train))
kable(summary(test))
model.building <- function(target, features, train, test, grp="LocationID", exclude.features = NULL, print.step.summ = FALSE, scale=TRUE, ...) {
if (!require("pacman")) install.packages("pacman")
pacman::p_load(lmerTest, glue, knitr, car, sjPlot, MuMIn, ggplot2, gridExtra, ModelMetrics)
# Remove the excluded features from the feature vector
if (length(exclude.features)>=1) {
features <- grep(paste0(exclude.features, collapse = "|"), features, invert=TRUE, value=TRUE)
}
features.string <- paste(features, collapse = " + ")
formula <- as.formula(glue(target, " ~ 1 + ", features.string, " + (1 + ", features.string, "|", grp, ")"))
train.data <- train
test.data <- test
if (scale) {
train.data[c(features)] <- scale(train.data[c(features)])
}
# Fit initial model and run stepwise feature selection
init.model <- lmer(formula, data=train.data)
step.model <- step(init.model, data=train.data, reduce.random=TRUE)
scaled.model <- get_model(step.model)
formula <- formula(scaled.model)
model <- lmer(formula, data=train)
if (print.step.summ) {
print(step.model$fixed)
print(step.model$random)
print(summary(model))
}
# kable(vif(model))
# print(tab_model(model, show.icc=TRUE, collapse.ci=TRUE, show.aic=TRUE))
print(plot_model(model, type="re", title=glue("Random effects - ", target), show.values=TRUE))
print(plot_model(model, show.values=TRUE))
print(r.squaredGLMM(model))
# Generating predictions and evaluating for training and test set
pred.results <- pred.plots(model, target, train.data, test.data, grp=grp)
results <- list("step.results" = step.model, "model" = model, "pred.results"= pred.results, "scaled.model"=scaled.model)
}
pred.plots <- function(model, target, train.data, test.data, grp="LocationID") {
if (!require("pacman")) install.packages("pacman")
pacman::p_load(knitr, ModelMetrics, gridExtra, ggplot2, glue)
train.pred <- train.data[grp]
train.pred$actual <- train.data[target][[1]]
train.pred$pred <- predict(model)
test.pred <- test.data[grp]
test.pred$actual <- test.data[target][[1]]
test.pred$pred <- predict(model, newdata=test.data)
# Calculate the normalised RMSE
# range <- abs(max(train.pred$actual) - min(train.pred$actual))
train.mae <- MAE(train.pred$pred, train.pred$actual)
test.mae <- MAE(test.pred$pred, test.pred$actual)
# Plot predicted vs actual
test.title <- glue("Test Set (MAE=", round(test.mae, 3), ")", sep="")
test.plot <- ggplot(test.pred, aes(x=pred, y=actual, colour=LocationID)) +
geom_point() +
geom_abline(intercept=0, slope=1) +
labs(x = 'Predicted Values', y='Actual Values', title=test.title)+
coord_fixed() +
theme(legend.position="none")
train.title <- glue("Train Set (MAE=", round(train.mae, 3), ")", sep="")
train.plot <- ggplot(train.pred, aes(x=pred, y=actual, colour=LocationID)) +
geom_point() +
geom_abline(intercept=0, slope=1) +
labs(x = 'Predicted Values', y='Actual Values', title=train.title) +
coord_fixed() +
theme(legend.position="none")
grid.arrange(train.plot, test.plot, nrow=1)
results <- list("train.pred" = train.pred, "test.pred" = test.pred, "test.mae" = test.mae, "train.mae" = train.mae)
}
Pleasant.results <- model.building(target="ISOPleasant", features = features, train = train, test = test, grp="LocationID")
exists(data)
lockdownData
test
train
exists(test)
??exists
?type
typeof(test)
model.building <- function(target, features, train, test, grp="LocationID", exclude.features = NULL, print.step.summ = FALSE, scale=TRUE, ...) {
if (!require("pacman")) install.packages("pacman")
pacman::p_load(lmerTest, glue, knitr, car, sjPlot, MuMIn, ggplot2, gridExtra, ModelMetrics)
# Remove the excluded features from the feature vector
if (length(exclude.features)>=1) {
features <- grep(paste0(exclude.features, collapse = "|"), features, invert=TRUE, value=TRUE)
}
features.string <- paste(features, collapse = " + ")
formula <- as.formula(glue(target, " ~ 1 + ", features.string, " + (1 + ", features.string, "|", grp, ")"))
train.data <- train
test.data <- test
if (scale) {
train.data[c(features)] <- scale(train.data[c(features)])
}
# Fit initial model and run stepwise feature selection
init.model <- lmer(formula, data=train.data)
print(typeof(train.data))
step.model <- step(init.model, data=train.data, reduce.random=TRUE)
scaled.model <- get_model(step.model)
formula <- formula(scaled.model)
model <- lmer(formula, data=train)
if (print.step.summ) {
print(step.model$fixed)
print(step.model$random)
print(summary(model))
}
# kable(vif(model))
# print(tab_model(model, show.icc=TRUE, collapse.ci=TRUE, show.aic=TRUE))
print(plot_model(model, type="re", title=glue("Random effects - ", target), show.values=TRUE))
print(plot_model(model, show.values=TRUE))
print(r.squaredGLMM(model))
# Generating predictions and evaluating for training and test set
pred.results <- pred.plots(model, target, train.data, test.data, grp=grp)
results <- list("step.results" = step.model, "model" = model, "pred.results"= pred.results, "scaled.model"=scaled.model)
}
pred.plots <- function(model, target, train.data, test.data, grp="LocationID") {
if (!require("pacman")) install.packages("pacman")
pacman::p_load(knitr, ModelMetrics, gridExtra, ggplot2, glue)
train.pred <- train.data[grp]
train.pred$actual <- train.data[target][[1]]
train.pred$pred <- predict(model)
test.pred <- test.data[grp]
test.pred$actual <- test.data[target][[1]]
test.pred$pred <- predict(model, newdata=test.data)
# Calculate the normalised RMSE
# range <- abs(max(train.pred$actual) - min(train.pred$actual))
train.mae <- MAE(train.pred$pred, train.pred$actual)
test.mae <- MAE(test.pred$pred, test.pred$actual)
# Plot predicted vs actual
test.title <- glue("Test Set (MAE=", round(test.mae, 3), ")", sep="")
test.plot <- ggplot(test.pred, aes(x=pred, y=actual, colour=LocationID)) +
geom_point() +
geom_abline(intercept=0, slope=1) +
labs(x = 'Predicted Values', y='Actual Values', title=test.title)+
coord_fixed() +
theme(legend.position="none")
train.title <- glue("Train Set (MAE=", round(train.mae, 3), ")", sep="")
train.plot <- ggplot(train.pred, aes(x=pred, y=actual, colour=LocationID)) +
geom_point() +
geom_abline(intercept=0, slope=1) +
labs(x = 'Predicted Values', y='Actual Values', title=train.title) +
coord_fixed() +
theme(legend.position="none")
grid.arrange(train.plot, test.plot, nrow=1)
results <- list("train.pred" = train.pred, "test.pred" = test.pred, "test.mae" = test.mae, "train.mae" = train.mae)
}
Pleasant.results <- model.building(target="ISOPleasant", features = features, train = train, test = test, grp="LocationID")
knitr::opts_chunk$set(echo = TRUE)
init_features <- c("Loudness_N5(soneGF)", "Sharpness_S(acum)", "Rough_HM_R(asper)", "I_HM_I(iu)", "FS_(vacil)", "LAeq_L(A)(dB(SPL))", "LA10_LA90(dB(SPL))", "LCeq_LAeq(dB(SPL))", "SIL3_Avg,arith(dB(SPL))")
init_feature_string <- paste(init_features, collapse = " + ")
init_feature_string
library(glue)
library(tidyr)
library(here)
library(knitr)
library(dplyr)
library(readxl)
data <- read_excel(here("data", "2021-05-05", "SSID Europe Database V1.0.xlsx"), sheet = "Master Merge")
data <- as_tibble(data)
data <- data[c("GroupID", "LocationID", "Lockdown", "ISOPleasant", "ISOEventful", "Human", "Traffic", "Natural", init_features)]
data <- rename(data, "N5" = "Loudness_N5(soneGF)")
data <- rename(data, "S" = "Sharpness_S(acum)")
data <- rename(data, "R" = "Rough_HM_R(asper)")
data <- rename(data, "I" = "I_HM_I(iu)")
data <- rename(data, "FS" = "FS_(vacil)")
data <- rename(data, "LAeq" = "LAeq_L(A)(dB(SPL))")
data <- rename(data, "LA10_LA90" = "LA10_LA90(dB(SPL))")
data <- rename(data, "LCeq_LAeq" = "LCeq_LAeq(dB(SPL))")
data <- rename(data, "SIL3" = "SIL3_Avg,arith(dB(SPL))")
features <- c("N5", "S", "R", "I", "FS", "LAeq", "LA10_LA90", "LCeq_LAeq", "SIL3")
feature_string <- paste(features, collapse = " + ")
feature_string
locations <- c("CamdenTown", "EustonTap", "MarchmontGarden", "MonumentoGaribaldi", "PancrasLock", "RegentsParkFields", "RegentsParkJapan", "RussellSq", "SanMarco", "StPaulsCross", "StPaulsRow", "TateModern", "TorringtonSq")
data <- data %>%
filter(LocationID %in% locations)
print("Full data table has dimensions: ")
print(dim(data))
kable(print(head(data)))
data <- data %>% mutate_at(vars(GroupID, LocationID, Lockdown), funs(as.factor))
data <- data %>% mutate_at(vars(c("ISOPleasant", "ISOEventful", "Traffic", "Human", "Natural", features)), funs(as.numeric))
kable(head(data))
prelockdownData <- data %>% filter(Lockdown == 1)
lockdownData <- data %>% filter(Lockdown == 2)
prelockdownData <- drop_na(prelockdownData)
# prelockdownData[c(features)] <- scale(prelockdownData[c(features)])
# Train-test split
library(groupdata2)
set.seed(42)
parts = partition(prelockdownData, p=0.2, cat_col="LocationID")
train = parts[[2]]
test = parts[[1]]
kable(summary(train))
kable(summary(test))
model.building <- function(target, features, train, test, grp="LocationID", exclude.features = NULL, print.step.summ = FALSE, scale=TRUE, ...) {
if (!require("pacman")) install.packages("pacman")
pacman::p_load(lmerTest, glue, knitr, car, sjPlot, MuMIn, ggplot2, gridExtra, ModelMetrics)
# Remove the excluded features from the feature vector
if (length(exclude.features)>=1) {
features <- grep(paste0(exclude.features, collapse = "|"), features, invert=TRUE, value=TRUE)
}
features.string <- paste(features, collapse = " + ")
formula <- as.formula(glue(target, " ~ 1 + ", features.string, " + (1 + ", features.string, "|", grp, ")"))
train.data <- train
test.data <- test
if (scale) {
train.data[c(features)] <- scale(train.data[c(features)])
}
# Fit initial model and run stepwise feature selection
init.model <- lmer(formula, data=train.data)
print(typeof(train.data))
step.model <- step(init.model, data=train.data, reduce.random=TRUE)
scaled.model <- get_model(step.model)
formula <- formula(scaled.model)
model <- lmer(formula, data=train)
if (print.step.summ) {
print(step.model$fixed)
print(step.model$random)
print(summary(model))
}
# kable(vif(model))
# print(tab_model(model, show.icc=TRUE, collapse.ci=TRUE, show.aic=TRUE))
print(plot_model(model, type="re", title=glue("Random effects - ", target), show.values=TRUE))
print(plot_model(model, show.values=TRUE))
print(r.squaredGLMM(model))
# Generating predictions and evaluating for training and test set
pred.results <- pred.plots(model, target, train.data, test.data, grp=grp)
results <- list("step.results" = step.model, "model" = model, "pred.results"= pred.results, "scaled.model"=scaled.model)
}
pred.plots <- function(model, target, train.data, test.data, grp="LocationID") {
if (!require("pacman")) install.packages("pacman")
pacman::p_load(knitr, ModelMetrics, gridExtra, ggplot2, glue)
train.pred <- train.data[grp]
train.pred$actual <- train.data[target][[1]]
train.pred$pred <- predict(model)
test.pred <- test.data[grp]
test.pred$actual <- test.data[target][[1]]
test.pred$pred <- predict(model, newdata=test.data)
# Calculate the normalised RMSE
# range <- abs(max(train.pred$actual) - min(train.pred$actual))
train.mae <- MAE(train.pred$pred, train.pred$actual)
test.mae <- MAE(test.pred$pred, test.pred$actual)
# Plot predicted vs actual
test.title <- glue("Test Set (MAE=", round(test.mae, 3), ")", sep="")
test.plot <- ggplot(test.pred, aes(x=pred, y=actual, colour=LocationID)) +
geom_point() +
geom_abline(intercept=0, slope=1) +
labs(x = 'Predicted Values', y='Actual Values', title=test.title)+
coord_fixed() +
theme(legend.position="none")
train.title <- glue("Train Set (MAE=", round(train.mae, 3), ")", sep="")
train.plot <- ggplot(train.pred, aes(x=pred, y=actual, colour=LocationID)) +
geom_point() +
geom_abline(intercept=0, slope=1) +
labs(x = 'Predicted Values', y='Actual Values', title=train.title) +
coord_fixed() +
theme(legend.position="none")
grid.arrange(train.plot, test.plot, nrow=1)
results <- list("train.pred" = train.pred, "test.pred" = test.pred, "test.mae" = test.mae, "train.mae" = train.mae)
}
Pleasant.results <- model.building(target="ISOPleasant", features = features, train = train, test = test, grp="LocationID")
?MAE
??MAE
model.building <- function(target, features, train, test, grp="LocationID", exclude.features = NULL, print.step.summ = FALSE, scale=TRUE, ...) {
if (!require("pacman")) install.packages("pacman")
pacman::p_load(lmerTest, glue, knitr, car, sjPlot, MuMIn, ggplot2, gridExtra, ModelMetrics)
# Remove the excluded features from the feature vector
if (length(exclude.features)>=1) {
features <- grep(paste0(exclude.features, collapse = "|"), features, invert=TRUE, value=TRUE)
}
features.string <- paste(features, collapse = " + ")
formula <- as.formula(glue(target, " ~ 1 + ", features.string, " + (1 + ", features.string, "|", grp, ")"))
train.data <- train
test.data <- test
if (scale) {
train.data[c(features)] <- scale(train.data[c(features)])
}
# Fit initial model and run stepwise feature selection
init.model <- lmer(formula, data=train.data)
print(typeof(train.data))
step.model <- step(init.model, data=train.data, reduce.random=TRUE)
scaled.model <- get_model(step.model)
formula <- formula(scaled.model)
model <- lmer(formula, data=train)
if (print.step.summ) {
print(step.model$fixed)
print(step.model$random)
print(summary(model))
}
# kable(vif(model))
# print(tab_model(model, show.icc=TRUE, collapse.ci=TRUE, show.aic=TRUE))
print(plot_model(model, type="re", title=glue("Random effects - ", target), show.values=TRUE))
print(plot_model(model, show.values=TRUE))
print(r.squaredGLMM(model))
# Generating predictions and evaluating for training and test set
pred.results <- pred.plots(model, target, train.data, test.data, grp=grp)
results <- list("step.results" = step.model, "model" = model, "pred.results"= pred.results, "scaled.model"=scaled.model)
}
pred.plots <- function(model, target, train.data, test.data, grp="LocationID") {
if (!require("pacman")) install.packages("pacman")
pacman::p_load(knitr, ModelMetrics, gridExtra, ggplot2, glue)
train.pred <- train.data[grp]
train.pred$actual <- train.data[target][[1]]
train.pred$pred <- predict(model)
test.pred <- test.data[grp]
test.pred$actual <- test.data[target][[1]]
test.pred$pred <- predict(model, newdata=test.data)
# Calculate the normalised RMSE
# range <- abs(max(train.pred$actual) - min(train.pred$actual))
train.mae <- mae(train.pred$pred, train.pred$actual)
test.mae <- mae(test.pred$pred, test.pred$actual)
# Plot predicted vs actual
test.title <- glue("Test Set (MAE=", round(test.mae, 3), ")", sep="")
test.plot <- ggplot(test.pred, aes(x=pred, y=actual, colour=LocationID)) +
geom_point() +
geom_abline(intercept=0, slope=1) +
labs(x = 'Predicted Values', y='Actual Values', title=test.title)+
coord_fixed() +
theme(legend.position="none")
train.title <- glue("Train Set (MAE=", round(train.mae, 3), ")", sep="")
train.plot <- ggplot(train.pred, aes(x=pred, y=actual, colour=LocationID)) +
geom_point() +
geom_abline(intercept=0, slope=1) +
labs(x = 'Predicted Values', y='Actual Values', title=train.title) +
coord_fixed() +
theme(legend.position="none")
grid.arrange(train.plot, test.plot, nrow=1)
results <- list("train.pred" = train.pred, "test.pred" = test.pred, "test.mae" = test.mae, "train.mae" = train.mae)
}
Pleasant.results <- model.building(target="ISOPleasant", features = features, train = train, test = test, grp="LocationID", exclude.features = c("LAeq"))
