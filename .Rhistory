library(tidyr)
library(here)
library(knitr)
library(dplyr)
library(readxl)
data <- read_excel(here("data", "2021-05-18", "SSID Europe Database V1.0.xlsx"), sheet = "Master Merge")
data <- as_tibble(data)
data <- data[c("GroupID", "LocationID", "Lockdown", "ISOPleasant", "ISOEventful", "Human", "Traffic", "Natural", init_features)]
data <- rename(data, "PA" = "PA(Zwicker)")
data <- rename(data, "N5" = "Loudness_N5(soneGF)")
data <- rename(data, "S" = "Sharpness_S(acum)")
data <- rename(data, "R" = "Rough_HM_R(asper)")
data <- rename(data, "I" = "I_HM_I(iu)")
data <- rename(data, "FS" = "FS_(vacil)")
data <- rename(data, "T" = "Ton_HM_Avg,arith(tuHMS)")
data <- rename(data, "LAeq" = "LAeq_L(A)(dB(SPL))")
data <- rename(data, "LA10_LA90" = "LA10_LA90(dB(SPL))")
data <- rename(data, "LCeq_LAeq" = "LCeq_LAeq(dB(SPL))")
data <- rename(data, "SIL3" = "SIL3_Avg,arith(dB(SPL))")
features <- c("PA", "N5", "S", "R", "I", "FS", "T", "LAeq", "LA10_LA90", "LCeq_LAeq", "SIL3")
feature_string <- paste(features, collapse = " + ")
feature_string
locations <- c("CamdenTown", "EustonTap", "MarchmontGarden", "MonumentoGaribaldi", "PancrasLock", "RegentsParkFields", "RegentsParkJapan", "RussellSq", "SanMarco", "StPaulsCross", "StPaulsRow", "TateModern", "TorringtonSq")
data <- data %>%
filter(LocationID %in% locations)
print(glue("Full data table has dimensions: ", dim(data)))
dim(data)
glue("Dimensions:", dim(data))
glue("Dimensions:", list(dim(data)))
glue("Dimensions:", c(dim(data)))
glue("Dimensions:", list(dim(data))[0])
dim(data)[0]
dim(data)[1]
dim(data)[2]
glue("Dimensions:", dim(data)[1], ", ", dim(data)[2])
library(glue)
library(tidyr)
library(here)
library(knitr)
library(dplyr)
library(readxl)
data <- read_excel(here("data", "2021-05-18", "SSID Europe Database V1.0.xlsx"), sheet = "Master Merge")
data <- as_tibble(data)
data <- data[c("GroupID", "LocationID", "Lockdown", "ISOPleasant", "ISOEventful", "Human", "Traffic", "Natural", init_features)]
data <- rename(data, "PA" = "PA(Zwicker)")
data <- rename(data, "N5" = "Loudness_N5(soneGF)")
data <- rename(data, "S" = "Sharpness_S(acum)")
data <- rename(data, "R" = "Rough_HM_R(asper)")
data <- rename(data, "I" = "I_HM_I(iu)")
data <- rename(data, "FS" = "FS_(vacil)")
data <- rename(data, "T" = "Ton_HM_Avg,arith(tuHMS)")
data <- rename(data, "LAeq" = "LAeq_L(A)(dB(SPL))")
data <- rename(data, "LA10_LA90" = "LA10_LA90(dB(SPL))")
data <- rename(data, "LCeq_LAeq" = "LCeq_LAeq(dB(SPL))")
data <- rename(data, "SIL3" = "SIL3_Avg,arith(dB(SPL))")
features <- c("PA", "N5", "S", "R", "I", "FS", "T", "LAeq", "LA10_LA90", "LCeq_LAeq", "SIL3")
feature_string <- paste(features, collapse = " + ")
feature_string
locations <- c("CamdenTown", "EustonTap", "MarchmontGarden", "MonumentoGaribaldi", "PancrasLock", "RegentsParkFields", "RegentsParkJapan", "RussellSq", "SanMarco", "StPaulsCross", "StPaulsRow", "TateModern", "TorringtonSq")
data <- data %>%
filter(LocationID %in% locations)
print(glue("Full data table has dimensions: ", dim(data)[1], ", ", dim(data)[2]))
kable(head(data))
data <- data %>% mutate_at(vars(GroupID, LocationID, Lockdown), funs(as.factor))
data <- data %>% mutate_at(vars(c("ISOPleasant", "ISOEventful", "Traffic", "Human", "Natural", features)), funs(as.numeric))
kable(head(data))
library(correlation)
corrs <- correlation(data[features], multilevel=FALSE)
s <- summary(corrs)
display(s)
prelockdownData <- data %>% filter(Lockdown == 0)
lockdownData <- data %>% filter(Lockdown == 1)
prelockdownData <- drop_na(prelockdownData)
# prelockdownData[c(features)] <- scale(prelockdownData[c(features)])
# Train-test split
library(groupdata2)
set.seed(42)
parts = partition(prelockdownData, p=0.2, cat_col="LocationID")
train = parts[[2]]
test = parts[[1]]
kable(summary(train))
kable(summary(test))
model.building <- function(target, features, train, test, grp="LocationID", exclude.features = NULL, scale=TRUE, plot = TRUE, print.loc.means = TRUE, verbose = 0, ...) {
if (!require("pacman")) install.packages("pacman")
pacman::p_load(lmerTest, glue, knitr, car, sjPlot, MuMIn, ggplot2, gridExtra, ModelMetrics)
# Remove the excluded features from the feature vector
if (length(exclude.features)>=1) {
features <- grep(paste0(exclude.features, collapse = "|"), features, invert=TRUE, value=TRUE)
}
features.string <- paste(features, collapse = " + ")
formula <- as.formula(glue(target, " ~ 1 + ", features.string, " + (1 + ", features.string, "|", grp, ")"))
train.data <- train
test.data <- test
if (scale) {
train.data[c(features)] <- scale(train.data[c(features)])
}
# Fit initial model and run stepwise feature selection
if (verbose > 0) {print("Fitting initial model.")}
init.model <- lmer(formula, data=train.data)
if (verbose > 0) {print("Performing Feature Selection")}
step.model <- step(init.model, data=train.data, reduce.random=TRUE)
scaled.model <- get_model(step.model)
formula <- formula(scaled.model)
if (verbose > 0) {print("Fitting Final Model")}
model <- lmer(formula, data=train)
if (verbose > 1) {
print(step.model$fixed)
print(step.model$random)
print(summary(model))
}
# kable(vif(model))
if (plot) {
# print(tab_model(model, show.icc=TRUE, collapse.ci=TRUE, show.aic=TRUE))
print(plot_model(scaled.model, type="re", title=glue("Random effects - ", target), show.values=TRUE))
print(plot_model(scaled.model, show.values=TRUE))
print("Trained model MLM R-squared:")
print(r.squaredGLMM(model))
# Generating predictions and evaluating for training and test set
pred.results <- pred.plots(model, target, train.data, test.data, grp=grp)
}
results <- list("step.results" = step.model, "model" = model, "pred.results"= pred.results, "scaled.model"=scaled.model)
means <- location.score(results, print=print.loc.means)
results[["train.means"]] = means$train.means
results[["test.means"]] = means$test.means
results[["train.loc.mae"]] = means$train.loc.mae
results[["train.loc.r2"]] = means$train.loc.r2
results[["test.loc.mae"]] = means$test.loc.mae
results[["test.loc.r2"]] = means$test.loc.r2
results
}
pred.plots <- function(model, target, train.data, test.data, grp="LocationID") {
if (!require("pacman")) install.packages("pacman")
pacman::p_load(knitr, ModelMetrics, gridExtra, ggplot2, glue)
train.pred <- train.data[grp]
train.pred$actual <- train.data[target][[1]]
train.pred$pred <- predict(model)
test.pred <- test.data[grp]
test.pred$actual <- test.data[target][[1]]
test.pred$pred <- predict(model, newdata=test.data)
# Calculate the normalised RMSE
# range <- abs(max(train.pred$actual) - min(train.pred$actual))
train.mae <- mae(train.pred$pred, train.pred$actual)
test.mae <- mae(test.pred$pred, test.pred$actual)
# Plot predicted vs actual
test.title <- glue("Test Set (MAE=", round(test.mae, 3), ")", sep="")
test.plot <- ggplot(test.pred, aes(x=pred, y=actual, colour=LocationID)) +
geom_point() +
geom_abline(intercept=0, slope=1) +
labs(x = 'Predicted Values', y='Actual Values', title=test.title)+
coord_fixed() +
theme(legend.position="none")
train.title <- glue("Train Set (MAE=", round(train.mae, 3), ")", sep="")
train.plot <- ggplot(train.pred, aes(x=pred, y=actual, colour=LocationID)) +
geom_point() +
geom_abline(intercept=0, slope=1) +
labs(x = 'Predicted Values', y='Actual Values', title=train.title) +
coord_fixed() +
theme(legend.position="none")
grid.arrange(train.plot, test.plot, nrow=1)
results <- list("train.pred" = train.pred, "test.pred" = test.pred, "test.mae" = test.mae, "train.mae" = train.mae)
}
location.score <- function(model.results, print=TRUE) {
pacman::p_load(dplyr, ModelMetrics, MLmetrics, glue)
pred.results <- model.results$pred.results
train.pred <- pred.results$train.pred
test.pred <- pred.results$test.pred
model <- model.results$model
train.means <- train.pred %>%
group_by(LocationID) %>%
summarise_at(vars(actual, pred), funs(mean(., na.rm=TRUE)))
test.means <- test.pred %>%
group_by(LocationID) %>%
summarise_at(vars(actual, pred), funs(mean(., na.rm=TRUE)))
train.loc.mae <- mae(train.means$pred, train.means$actual)
train.loc.r2 <- R2_Score(train.means$pred, train.means$actual)
test.loc.mae <- mae(test.means$pred, test.means$actual)
test.loc.r2 <- R2_Score(test.means$pred, test.means$actual)
if (print) {
print(glue("Train Location R^2: ", round(train.loc.r2, 3)))
print(glue("Test Location R^2:  ", round(test.loc.r2, 3)))
}
results <- list(
"train.means" = train.means,
"test.means" = test.means,
"train.loc.mae" = train.loc.mae,
"train.loc.r2" = train.loc.r2,
"test.loc.mae" = test.loc.mae,
"test.loc.r2" = test.loc.r2)
}
Pleasant.results <- model.building(target="ISOPleasant", features = features, train = train, test = test, grp="LocationID", exclude.features = c("SIL3"), verbose=verbosity)
knitr::opts_chunk$set(echo = TRUE)
verbosity = 0
init_features <- c("PA(Zwicker)", "Loudness_N5(soneGF)", "Sharpness_S(acum)", "Rough_HM_R(asper)", "I_HM_I(iu)", "FS_(vacil)", "Ton_HM_Avg,arith(tuHMS)", "LAeq_L(A)(dB(SPL))", "LA10_LA90(dB(SPL))", "LCeq_LAeq(dB(SPL))", "SIL3_Avg,arith(dB(SPL))")
init_feature_string <- paste(init_features, collapse = " + ")
init_feature_string
library(glue)
library(tidyr)
library(here)
library(knitr)
library(dplyr)
library(readxl)
data <- read_excel(here("data", "2021-05-18", "SSID Europe Database V1.0.xlsx"), sheet = "Master Merge")
data <- as_tibble(data)
data <- data[c("GroupID", "LocationID", "Lockdown", "ISOPleasant", "ISOEventful", "Human", "Traffic", "Natural", init_features)]
data <- rename(data, "PA" = "PA(Zwicker)")
data <- rename(data, "N5" = "Loudness_N5(soneGF)")
data <- rename(data, "S" = "Sharpness_S(acum)")
data <- rename(data, "R" = "Rough_HM_R(asper)")
data <- rename(data, "I" = "I_HM_I(iu)")
data <- rename(data, "FS" = "FS_(vacil)")
data <- rename(data, "T" = "Ton_HM_Avg,arith(tuHMS)")
data <- rename(data, "LAeq" = "LAeq_L(A)(dB(SPL))")
data <- rename(data, "LA10_LA90" = "LA10_LA90(dB(SPL))")
data <- rename(data, "LCeq_LAeq" = "LCeq_LAeq(dB(SPL))")
data <- rename(data, "SIL3" = "SIL3_Avg,arith(dB(SPL))")
features <- c("PA", "N5", "S", "R", "I", "FS", "T", "LAeq", "LA10_LA90", "LCeq_LAeq", "SIL3")
feature_string <- paste(features, collapse = " + ")
feature_string
locations <- c("CamdenTown", "EustonTap", "MarchmontGarden", "MonumentoGaribaldi", "PancrasLock", "RegentsParkFields", "RegentsParkJapan", "RussellSq", "SanMarco", "StPaulsCross", "StPaulsRow", "TateModern", "TorringtonSq")
data <- data %>%
filter(LocationID %in% locations)
print(glue("Full data table has dimensions: ", dim(data)[1], ", ", dim(data)[2]))
kable(head(data))
data <- data %>% mutate_at(vars(GroupID, LocationID, Lockdown, "Traffic", "Human", "Natural"), funs(as.factor))
data <- data %>% mutate_at(vars(c("ISOPleasant", "ISOEventful", features)), funs(as.numeric))
kable(head(data))
library(correlation)
corrs <- correlation(data[features], multilevel=FALSE)
s <- summary(corrs)
display(s)
prelockdownData <- data %>% filter(Lockdown == 0)
lockdownData <- data %>% filter(Lockdown == 1)
prelockdownData <- drop_na(prelockdownData)
# Train-test split
library(groupdata2)
set.seed(42)
parts = partition(prelockdownData, p=0.2, cat_col="LocationID")
train = parts[[2]]
test = parts[[1]]
kable(summary(train))
kable(summary(test))
Natural.results$model
formula(Natural.results$model)
Natural.logit.model <- lmer(Natural ~ S + LCeq_LAeq + SIL3 + (S|LocationID), family = binomial(link="logit"))
Natural.logit.model <- lme4::lmer(Natural ~ S + LCeq_LAeq + SIL3 + (S|LocationID), family = binomial(link="logit"))
library(ordinal)
install.packages("ordinal")
library(ordinal)
Natural.logit.model <- clmm(Natural ~ S + LCeq_LAeq + SIL3 + (S|LocationID), data = train)
display(Natural.logit.model)
Natural.logit.model <- clmm(Natural ~ S + LCeq_LAeq + SIL3 + (S|LocationID), data = train)
Summary(Natural.logit.model)
summary(Natural.logit.model)
stepAIC(Natural.logit.model)
MASS::stepAIC(Natural.logit.model)
MuMIn::r.squaredGLMM(Natural.logit.model)
Natural.logit.model <- lmer(Natural ~ S + LCeq_LAeq + SIL3 + (S|LocationID), data = train)
Natural.logit.model <- lmer(Natural ~ S + LCeq_LAeq + SIL3 + (S|LocationID), data = train, family=binomial(link = "logit"))
Natural.logit.model <- glmer(Natural ~ S + LCeq_LAeq + SIL3 + (S|LocationID), data = train, family=binomial)
summary(Natural.logit.model)
MASS::stepAIC(Natural.logit.model)
lmerTest::step(Natural.logit.model)
Natural.logit.model <- lmer(Natural ~ S + LCeq_LAeq + SIL3 + (S|LocationID), data = train, family=binomial)
sjPlot::tab_model(Natural.logit.model)
library(cAIC4)
stepcAIC(Natural.logit.model)
feature_string
features
Natural.logit.model <- glmer(Natural ~ PA + N5 + S + R + I + FS + T + LAeq + LA10_LA90 + LCeq_LAeq + SIL3 + (PA + N5 + S + R + I + FS + T + LAeq + LA10_LA90 + LCeq_LAeq + SIL3 | LocationID), data = train, family=binomial)
natural.train <- train
natural.train[c(features)] <- scale(natural.train[c(features)])
Natural.logit.model <- glmer(Natural ~ PA + N5 + S + R + I + FS + T + LAeq + LA10_LA90 + LCeq_LAeq + SIL3 + (PA + N5 + S + R + I + FS + T + LAeq + LA10_LA90 + LCeq_LAeq + SIL3 | LocationID), data = natural.train, family=binomial)
Natural.step <- stepcAIC(Natural.logit.model, groupCandidates = LocationID, slopeCandidates = features, fixEfCandidates = features, numberOfPermissibleSlopes = length(features), direction = "forward")
natural.train <- train
natural.train[c(features)] <- scale(natural.train[c(features)])
Natural.logit.model <- glmer(Natural ~ PA + N5 + S + R + I + FS + T + LAeq + LA10_LA90 + LCeq_LAeq + SIL3 + (PA + N5 + S + R + I + FS + T + LAeq + LA10_LA90 + LCeq_LAeq + SIL3 | LocationID), data = natural.train, family=binomial)
natural.train <- train
natural.train[c(features)] <- scale(natural.train[c(features)])
Natural.logit.model <- glmer(Natural ~ PA + N5 + S + R + I + FS + T + LAeq + LA10_LA90 + LCeq_LAeq + SIL3 + (PA + N5 + S + R + I + FS + T + LAeq + LA10_LA90 + LCeq_LAeq + SIL3 | LocationID), data = natural.train, family=binomial)
Natural.step <- stepcAIC(Natural.logit.model, groupCandidates = c("LocationID"), slopeCandidates = features, fixEfCandidates = features, numberOfPermissibleSlopes = length(features), direction = "forward", trace=TRUE)
natural.train <- train
natural.train[c(features)] <- scale(natural.train[c(features)])
Natural.logit.model <- glmer(Natural ~ PA + N5 + S + R + I + FS + (PA + N5 + S + R + I + FS + | LocationID), data = natural.train, family=binomial)
natural.train <- train
natural.train[c(features)] <- scale(natural.train[c(features)])
Natural.logit.model <- glmer(Natural ~ PA + N5 + S + R + I + FS + (PA + N5 + S + R + I + FS | LocationID), data = natural.train, family=binomial)
Natural.step <- stepcAIC(Natural.logit.model, groupCandidates = c("LocationID"), slopeCandidates = features, fixEfCandidates = features, numberOfPermissibleSlopes = length(features), direction = "forward", trace=TRUE, numCores = 4)
Natural.logit.model
sjPlot::tab_model(Natural.logit.model)
sjPlot::tab_model(Natural.results$model)
Traffic.logit.model <- glmer(Traffic ~ PA + N5 + S + R + I + FS + T + LAeq + LA10_LA90 + LCeq_LAeq + SIL3 + (PA + N5 + S + R + I + FS + T + LAeq + LA10_LA90 + LCeq_LAeq + SIL3 | LocationID), data = natural.train, family=binomial)
Traffic.step <- stepcAIC(Traffic.logit.model, groupCandidates = c("LocationID"), slopeCandidates = features, fixEfCandidates = features, numberOfPermissibleSlopes = length(features), direction = "forward", trace=TRUE, numCores = 4)
natural.train <- train
natural.train[c(features)] <- scale(natural.train[c(features)])
Natural.logit.model <- glmer(Natural ~ S + LCeq_LAeq + SIL3 + (S | LocationID), data = natural.train, family=binomial)
Natural.step <- stepcAIC(Natural.logit.model, groupCandidates = c("LocationID"), slopeCandidates = c("S"), fixEfCandidates = c("S", "LCeq_LAeq", "SIL3"), numberOfPermissibleSlopes = 1, direction = "forward", trace=TRUE, numCores = 4)
knitr::opts_chunk$set(echo = TRUE)
verbosity = 0
init_features <- c("PA(Zwicker)", "Loudness_N5(soneGF)", "Sharpness_S(acum)", "Rough_HM_R(asper)", "I_HM_I(iu)", "FS_(vacil)", "Ton_HM_Avg,arith(tuHMS)", "LAeq_L(A)(dB(SPL))", "LA10_LA90(dB(SPL))", "LCeq_LAeq(dB(SPL))", "SIL3_Avg,arith(dB(SPL))")
init_feature_string <- paste(init_features, collapse = " + ")
init_feature_string
library(glue)
library(tidyr)
library(here)
library(knitr)
library(dplyr)
library(readxl)
data <- read_excel(here("data", "2021-05-18", "SSID Europe Database V1.0.xlsx"), sheet = "Master Merge")
data <- as_tibble(data)
data <- data[c("GroupID", "LocationID", "Lockdown", "ISOPleasant", "ISOEventful", "Human", "Traffic", "Natural", init_features)]
data <- rename(data, "PA" = "PA(Zwicker)")
data <- rename(data, "N5" = "Loudness_N5(soneGF)")
data <- rename(data, "S" = "Sharpness_S(acum)")
data <- rename(data, "R" = "Rough_HM_R(asper)")
data <- rename(data, "I" = "I_HM_I(iu)")
data <- rename(data, "FS" = "FS_(vacil)")
data <- rename(data, "T" = "Ton_HM_Avg,arith(tuHMS)")
data <- rename(data, "LAeq" = "LAeq_L(A)(dB(SPL))")
data <- rename(data, "LA10_LA90" = "LA10_LA90(dB(SPL))")
data <- rename(data, "LCeq_LAeq" = "LCeq_LAeq(dB(SPL))")
data <- rename(data, "SIL3" = "SIL3_Avg,arith(dB(SPL))")
features <- c("PA", "N5", "S", "R", "I", "FS", "T", "LAeq", "LA10_LA90", "LCeq_LAeq", "SIL3")
feature_string <- paste(features, collapse = " + ")
feature_string
locations <- c("CamdenTown", "EustonTap", "MarchmontGarden", "MonumentoGaribaldi", "PancrasLock", "RegentsParkFields", "RegentsParkJapan", "RussellSq", "SanMarco", "StPaulsCross", "StPaulsRow", "TateModern", "TorringtonSq")
data <- data %>%
filter(LocationID %in% locations)
print(glue("Full data table has dimensions: ", dim(data)[1], ", ", dim(data)[2]))
kable(head(data))
data <- data %>% mutate_at(vars(GroupID, LocationID, Lockdown, "Traffic", "Human", "Natural"), funs(as.factor))
data <- data %>% mutate_at(vars(c("ISOPleasant", "ISOEventful", features)), funs(as.numeric))
kable(head(data))
library(correlation)
corrs <- correlation(data[features], multilevel=FALSE)
s <- summary(corrs)
display(s)
prelockdownData <- data %>% filter(Lockdown == 0)
lockdownData <- data %>% filter(Lockdown == 1)
prelockdownData <- drop_na(prelockdownData)
# Train-test split
library(groupdata2)
set.seed(42)
parts = partition(prelockdownData, p=0.2, cat_col="LocationID")
train = parts[[2]]
test = parts[[1]]
kable(summary(train))
kable(summary(test))
model.building <- function(target, features, train, test, grp="LocationID", exclude.features = NULL, scale=TRUE, plot = TRUE, print.loc.means = TRUE, verbose = 0, ...) {
if (!require("pacman")) install.packages("pacman")
pacman::p_load(lmerTest, glue, knitr, car, sjPlot, MuMIn, ggplot2, gridExtra, ModelMetrics)
# Remove the excluded features from the feature vector
if (length(exclude.features)>=1) {
features <- grep(paste0(exclude.features, collapse = "|"), features, invert=TRUE, value=TRUE)
}
features.string <- paste(features, collapse = " + ")
formula <- as.formula(glue(target, " ~ 1 + ", features.string, " + (1 + ", features.string, "|", grp, ")"))
train.data <- train
test.data <- test
if (scale) {
train.data[c(features)] <- scale(train.data[c(features)])
}
# Fit initial model and run stepwise feature selection
if (verbose > 0) {print("Fitting initial model.")}
init.model <- lmer(formula, data=train.data)
if (verbose > 0) {print("Performing Feature Selection")}
step.model <- step(init.model, data=train.data, reduce.random=TRUE)
scaled.model <- get_model(step.model)
formula <- formula(scaled.model)
if (verbose > 0) {print("Fitting Final Model")}
model <- lmer(formula, data=train)
if (verbose > 1) {
print(step.model$fixed)
print(step.model$random)
print(summary(model))
}
# kable(vif(model))
if (plot) {
# print(tab_model(model, show.icc=TRUE, collapse.ci=TRUE, show.aic=TRUE))
print(plot_model(scaled.model, type="re", title=glue("Random effects - ", target), show.values=TRUE))
print(plot_model(scaled.model, show.values=TRUE))
print("Trained model MLM R-squared:")
print(r.squaredGLMM(model))
# Generating predictions and evaluating for training and test set
pred.results <- pred.plots(model, target, train.data, test.data, grp=grp)
}
results <- list("step.results" = step.model, "model" = model, "pred.results"= pred.results, "scaled.model"=scaled.model)
means <- location.score(results, print=print.loc.means)
results[["train.means"]] = means$train.means
results[["test.means"]] = means$test.means
results[["train.loc.mae"]] = means$train.loc.mae
results[["train.loc.r2"]] = means$train.loc.r2
results[["test.loc.mae"]] = means$test.loc.mae
results[["test.loc.r2"]] = means$test.loc.r2
results
}
pred.plots <- function(model, target, train.data, test.data, grp="LocationID") {
if (!require("pacman")) install.packages("pacman")
pacman::p_load(knitr, ModelMetrics, gridExtra, ggplot2, glue)
train.pred <- train.data[grp]
train.pred$actual <- train.data[target][[1]]
train.pred$pred <- predict(model)
test.pred <- test.data[grp]
test.pred$actual <- test.data[target][[1]]
test.pred$pred <- predict(model, newdata=test.data)
# Calculate the normalised RMSE
# range <- abs(max(train.pred$actual) - min(train.pred$actual))
train.mae <- mae(train.pred$pred, train.pred$actual)
test.mae <- mae(test.pred$pred, test.pred$actual)
# Plot predicted vs actual
test.title <- glue("Test Set (MAE=", round(test.mae, 3), ")", sep="")
test.plot <- ggplot(test.pred, aes(x=pred, y=actual, colour=LocationID)) +
geom_point() +
geom_abline(intercept=0, slope=1) +
labs(x = 'Predicted Values', y='Actual Values', title=test.title)+
coord_fixed() +
theme(legend.position="none")
train.title <- glue("Train Set (MAE=", round(train.mae, 3), ")", sep="")
train.plot <- ggplot(train.pred, aes(x=pred, y=actual, colour=LocationID)) +
geom_point() +
geom_abline(intercept=0, slope=1) +
labs(x = 'Predicted Values', y='Actual Values', title=train.title) +
coord_fixed() +
theme(legend.position="none")
grid.arrange(train.plot, test.plot, nrow=1)
results <- list("train.pred" = train.pred, "test.pred" = test.pred, "test.mae" = test.mae, "train.mae" = train.mae)
}
location.score <- function(model.results, print=TRUE) {
pacman::p_load(dplyr, ModelMetrics, MLmetrics, glue)
pred.results <- model.results$pred.results
train.pred <- pred.results$train.pred
test.pred <- pred.results$test.pred
model <- model.results$model
train.means <- train.pred %>%
group_by(LocationID) %>%
summarise_at(vars(actual, pred), funs(mean(., na.rm=TRUE)))
test.means <- test.pred %>%
group_by(LocationID) %>%
summarise_at(vars(actual, pred), funs(mean(., na.rm=TRUE)))
train.loc.mae <- mae(train.means$pred, train.means$actual)
train.loc.r2 <- R2_Score(train.means$pred, train.means$actual)
test.loc.mae <- mae(test.means$pred, test.means$actual)
test.loc.r2 <- R2_Score(test.means$pred, test.means$actual)
if (print) {
print(glue("Train Location R^2: ", round(train.loc.r2, 3)))
print(glue("Test Location R^2:  ", round(test.loc.r2, 3)))
}
results <- list(
"train.means" = train.means,
"test.means" = test.means,
"train.loc.mae" = train.loc.mae,
"train.loc.r2" = train.loc.r2,
"test.loc.mae" = test.loc.mae,
"test.loc.r2" = test.loc.r2)
}
natural.train <- train
natural.train[c(features)] <- scale(natural.train[c(features)])
Natural.logit.model <- glmer(Natural ~ S + LCeq_LAeq + SIL3 + (S | LocationID), data = natural.train, family=binomial)
Natural.step <- stepcAIC(Natural.logit.model, groupCandidates = c("LocationID"), slopeCandidates = c("S"), fixEfCandidates = c("S", "LCeq_LAeq", "SIL3"), numberOfPermissibleSlopes = 1, direction = "forward", trace=TRUE, numCores = 4)
library(MASS)
natural.train <- train
natural.train[c(features)] <- scale(natural.train[c(features)])
Natural.logit.model <- glmer(Natural ~ S + LCeq_LAeq + SIL3 + (S | LocationID), data = natural.train, family=binomial)
Natural.step <- stepcAIC(Natural.logit.model, groupCandidates = c("LocationID"), slopeCandidates = c("S"), fixEfCandidates = c("S", "LCeq_LAeq", "SIL3"), numberOfPermissibleSlopes = 1, direction = "forward", trace=TRUE, numCores = 4)
?stepcAIC
??stepcAIC
library(cAIC4)
natural.train <- train
natural.train[c(features)] <- scale(natural.train[c(features)])
Natural.logit.model <- glmer(Natural ~ S + LCeq_LAeq + SIL3 + (S | LocationID), data = natural.train, family=binomial)
Natural.step <- stepcAIC(Natural.logit.model, groupCandidates = c("LocationID"), slopeCandidates = c("S"), fixEfCandidates = c("S", "LCeq_LAeq", "SIL3"), numberOfPermissibleSlopes = 1, direction = "forward", trace=TRUE, numCores = 4)
library(cAIC4)
natural.train <- train
natural.train[c(features)] <- scale(natural.train[c(features)])
Natural.logit.model <- glmer(Natural ~ S + LCeq_LAeq + SIL3 + (S | LocationID), data = natural.train, family=binomial)
Natural.step <- stepcAIC(Natural.logit.model, groupCandidates = c("LocationID"), slopeCandidates = c("S"), fixEfCandidates = c("S", "LCeq_LAeq", "SIL3"), numberOfPermissibleSlopes = 1, direction = "backward", trace=TRUE, numCores = 4)
library(cAIC4)
natural.train <- train
natural.train[c(features)] <- scale(natural.train[c(features)])
Natural.logit.model <- glmer(Natural ~ S + LCeq_LAeq + SIL3 + (S | LocationID), data = natural.train, family=binomial)
Natural.step <- stepcAIC(Natural.logit.model, groupCandidates = c("LocationID"), slopeCandidates = c("S"), fixEfCandidates = c("S", "LCeq_LAeq", "SIL3"), numberOfPermissibleSlopes = 1, direction = "backward", trace=TRUE, numCores = 4)
library(cAIC4)
natural.train <- train
natural.train[c(features)] <- scale(natural.train[c(features)])
Natural.logit.model <- glmer(Natural ~ S + LCeq_LAeq + SIL3 + (S | LocationID), data = natural.train, family=binomial)
Natural.step <- stepcAIC(Natural.logit.model, groupCandidates = c("LocationID"), direction = "backward", trace=TRUE, numCores = 4)
library(cAIC4)
natural.train <- train
natural.train[c(features)] <- scale(natural.train[c(features)])
Natural.logit.min <- glmer(Natural ~ 1 + (1 | LocationID), data = natural.train, family=binomial)
Natural.step <- stepcAIC(Natural.logit.model, groupCandidates = c("LocationID"), slopeCandidates = c("S"), fixEfCandidates = c("S", "LCeq_LAeq", "SIL3"), numberOfPermissibleSlopes = 1, direction = "forward", trace=TRUE, numCores = 4)
library(cAIC4)
natural.train <- train
natural.train[c(features)] <- scale(natural.train[c(features)])
Natural.logit.min <- glmer(Natural ~ 1 + (1 | LocationID), data = natural.train, family=binomial)
Natural.step <- stepcAIC(Natural.logit.model, groupCandidates = c("LocationID"), slopeCandidates = c("S"), fixEfCandidates = c("S", "LCeq_LAeq", "SIL3"), numberOfPermissibleSlopes = 1, direction = "forward", trace=TRUE, numCores = 4, steps=20)
Natural.logit.model
plot(Natural.logit.model)
sjPlot::plot_model(Natural.logit.model)
MuMIn::r.squaredGLMM(Natural.logit.model)
Natural.logit.min
Natural.logit.model$warning
Natural.logit.model
library(cAIC4)
natural.train <- train
natural.train[c(features)] <- scale(natural.train[c(features)])
Natural.logit.model <- glmer(Natural ~ S + LCeq_LAeq + SIL3 + (S | LocationID), data = natural.train, family=binomial)
Natural.step <- stepcAIC(Natural.logit.model, groupCandidates = c("LocationID"), slopeCandidates = c("S"), numberOfPermissibleSlopes = 1, direction = "backward", trace=TRUE, numCores = 4)
cAIC(Natural.logit.model)
Natural.logit.min
cAIC(Natural.logit.min)
library(glmmLasso)
glm1 <- glmmLasso(Natural ~ S + LCeq_LAeq + SIL3, rnd = list(LocationID=~1), family=binomial(link = "logit"), data=natural.train, lambda=100)
