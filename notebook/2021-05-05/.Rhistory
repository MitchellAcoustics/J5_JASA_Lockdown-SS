print("here 1")
# Plot predicted vs actual
test.title <- glue("Test Set (NRMSE=", round(test.nrmse, 3), ")", sep="")
test.plot <- ggplot(test.pred, aes(x=pred, y=actual, colour=LocationID)) +
geom_point() +
geom_abline(intercept=0, slope=1) +
labs(x = 'Predicted Values', y='Actual Values', title=test.title)+
coord_fixed() +
theme(legend.position="none")
train.title <- glue("Train Set (NRMSE=", round(train.nrmse, 3), ")", sep="")
train.plot <- ggplot(train.pred, aes(x=pred, y=actual, colour=LocationID)) +
geom_point() +
geom_abline(intercept=0, slope=1) +
labs(x = 'Predicted Values', y='Actual Values', title=train.title) +
coord_fixed() +
theme(legend.position="none")
grid.arrange(train.plot, test.plot, nrow=1)
results <- list("train.pred" = train.pred, "test.pred" = test.pred)
}
Pleasant.results <- model.building(target="ISOPleasant", features = features, train.data = train, test.data = test, grp="LocationID", exclude.features = c("LAeq"))
model.building <- function(target, features, train.data, test.data, grp="LocationID", exclude.features = NULL, ...) {
if (!require("pacman")) install.packages("pacman")
pacman::p_load(lmerTest, glue, knitr, car, sjPlot, MuMIn, ggplot2, gridExtra, ModelMetrics)
# Remove the excluded features from the feature vector
if (length(exclude.features)>=1) {
features <- grep(paste0(exclude.features, collapse = "|"), features, invert=TRUE, value=TRUE)
}
features.string <- paste(features, collapse = " + ")
formula <- as.formula(glue(target, " ~ 1 + ", features.string, " + (1 + ", features.string, "|", grp, ")"))
# Fit initial model and run stepwise feature selection
init.model <- lmer(formula, data=train.data)
step.model <- step(init.model, data=train.data, reduce.random=TRUE)
kable(step.model$fixed)
kable(step.model$random)
model <- get_model(step.model)
summary(model)
# kable(vif(model))
tab_model(model, show.icc=TRUE, collapse.ci=TRUE, show.aic=TRUE)
plot_model(model, type="re", title=glue("Random effects - ", target), show.values=TRUE)
plot_model(model, show.values=TRUE)
kable(r.squaredGLMM(model))
# Generating predictions and evaluating for training and test set
pred.results <- pred.plots(model, target, train.data, test.data, grp=grp)
results <- list("step.results" = step.model, "model" = model, "pred.results"= pred.results)
}
pred.plots <- function(model, target, train.data, test.data, grp="LocationID") {
if (!require("pacman")) install.packages("pacman")
pacman::p_load(knitr, ModelMetrics, gridExtra, ggplot2, glue)
train.pred <- train.data[grp]
train.pred$actual <- train.data[target][[1]]
train.pred$pred <- predict(model)
test.pred <- test.data[grp]
test.pred$actual <- test.data[target][[1]]
test.pred$pred <- predict(model, newdata=test.data)
# Calculate the normalised RMSE
print("here 1")
range <- abs(max(train.data$actual) - min(train.data$actual))
train.nrmse <- rmse(train.pred$pred, train.pred$actual) / range
test.nrmse <- rmse(test.pred$pred, test.pred$actual) / range
# Plot predicted vs actual
test.title <- glue("Test Set (NRMSE=", round(test.nrmse, 3), ")", sep="")
test.plot <- ggplot(test.pred, aes(x=pred, y=actual, colour=LocationID)) +
geom_point() +
geom_abline(intercept=0, slope=1) +
labs(x = 'Predicted Values', y='Actual Values', title=test.title)+
coord_fixed() +
theme(legend.position="none")
train.title <- glue("Train Set (NRMSE=", round(train.nrmse, 3), ")", sep="")
train.plot <- ggplot(train.pred, aes(x=pred, y=actual, colour=LocationID)) +
geom_point() +
geom_abline(intercept=0, slope=1) +
labs(x = 'Predicted Values', y='Actual Values', title=train.title) +
coord_fixed() +
theme(legend.position="none")
grid.arrange(train.plot, test.plot, nrow=1)
results <- list("train.pred" = train.pred, "test.pred" = test.pred)
}
Pleasant.results <- model.building(target="ISOPleasant", features = features, train.data = train, test.data = test, grp="LocationID", exclude.features = c("LAeq"))
# Calculate the normalised RMSE
range <- abs(max(train.pred$actual) - min(train.pred$actual))
model.building <- function(target, features, train.data, test.data, grp="LocationID", exclude.features = NULL, ...) {
if (!require("pacman")) install.packages("pacman")
pacman::p_load(lmerTest, glue, knitr, car, sjPlot, MuMIn, ggplot2, gridExtra, ModelMetrics)
# Remove the excluded features from the feature vector
if (length(exclude.features)>=1) {
features <- grep(paste0(exclude.features, collapse = "|"), features, invert=TRUE, value=TRUE)
}
features.string <- paste(features, collapse = " + ")
formula <- as.formula(glue(target, " ~ 1 + ", features.string, " + (1 + ", features.string, "|", grp, ")"))
# Fit initial model and run stepwise feature selection
init.model <- lmer(formula, data=train.data)
step.model <- step(init.model, data=train.data, reduce.random=TRUE)
kable(step.model$fixed)
kable(step.model$random)
model <- get_model(step.model)
summary(model)
# kable(vif(model))
tab_model(model, show.icc=TRUE, collapse.ci=TRUE, show.aic=TRUE)
plot_model(model, type="re", title=glue("Random effects - ", target), show.values=TRUE)
plot_model(model, show.values=TRUE)
kable(r.squaredGLMM(model))
# Generating predictions and evaluating for training and test set
pred.results <- pred.plots(model, target, train.data, test.data, grp=grp)
results <- list("step.results" = step.model, "model" = model, "pred.results"= pred.results)
}
pred.plots <- function(model, target, train.data, test.data, grp="LocationID") {
if (!require("pacman")) install.packages("pacman")
pacman::p_load(knitr, ModelMetrics, gridExtra, ggplot2, glue)
train.pred <- train.data[grp]
train.pred$actual <- train.data[target][[1]]
train.pred$pred <- predict(model)
test.pred <- test.data[grp]
test.pred$actual <- test.data[target][[1]]
test.pred$pred <- predict(model, newdata=test.data)
# Calculate the normalised RMSE
range <- abs(max(train.pred$actual) - min(train.pred$actual))
train.nrmse <- rmse(train.pred$pred, train.pred$actual) / range
test.nrmse <- rmse(test.pred$pred, test.pred$actual) / range
# Plot predicted vs actual
test.title <- glue("Test Set (NRMSE=", round(test.nrmse, 3), ")", sep="")
test.plot <- ggplot(test.pred, aes(x=pred, y=actual, colour=LocationID)) +
geom_point() +
geom_abline(intercept=0, slope=1) +
labs(x = 'Predicted Values', y='Actual Values', title=test.title)+
coord_fixed() +
theme(legend.position="none")
train.title <- glue("Train Set (NRMSE=", round(train.nrmse, 3), ")", sep="")
train.plot <- ggplot(train.pred, aes(x=pred, y=actual, colour=LocationID)) +
geom_point() +
geom_abline(intercept=0, slope=1) +
labs(x = 'Predicted Values', y='Actual Values', title=train.title) +
coord_fixed() +
theme(legend.position="none")
grid.arrange(train.plot, test.plot, nrow=1)
results <- list("train.pred" = train.pred, "test.pred" = test.pred)
}
Pleasant.results <- model.building(target="ISOPleasant", features = features, train.data = train, test.data = test, grp="LocationID", exclude.features = c("LAeq"))
test <- TRUE
if (test) {print("hi")}
if (test==TRUE) {print("hi")}
if (test!=TRUE) {print("hi")}
if (!test) {print("hi")}
formula(Pleasant.results)
formula(Pleasant.results$model)
knitr::opts_chunk$set(echo = TRUE)
init_features <- c("Loudness_N5(soneGF)", "Sharpness_S(acum)", "Rough_HM_R(asper)", "I_HM_I(iu)", "FS_(vacil)", "LAeq_L(A)(dB(SPL))", "LA10_LA90(dB(SPL))", "LCeq_LAeq(dB(SPL))", "SIL3_Avg,arith(dB(SPL))")
init_feature_string <- paste(init_features, collapse = " + ")
init_feature_string
library(glue)
library(tidyr)
library(here)
library(knitr)
library(dplyr)
library(readxl)
data <- read_excel(here("data", "2021-05-05", "SSID Europe Database V1.0.xlsx"), sheet = "Master Merge")
data <- as_tibble(data)
data <- data[c("GroupID", "LocationID", "Lockdown", "ISOPleasant", "ISOEventful", "Human", "Traffic", "Natural", init_features)]
data <- rename(data, "N5" = "Loudness_N5(soneGF)")
data <- rename(data, "S" = "Sharpness_S(acum)")
data <- rename(data, "R" = "Rough_HM_R(asper)")
data <- rename(data, "I" = "I_HM_I(iu)")
data <- rename(data, "FS" = "FS_(vacil)")
data <- rename(data, "LAeq" = "LAeq_L(A)(dB(SPL))")
data <- rename(data, "LA10_LA90" = "LA10_LA90(dB(SPL))")
data <- rename(data, "LCeq_LAeq" = "LCeq_LAeq(dB(SPL))")
data <- rename(data, "SIL3" = "SIL3_Avg,arith(dB(SPL))")
features <- c("N5", "S", "R", "I", "FS", "LAeq", "LA10_LA90", "LCeq_LAeq", "SIL3")
feature_string <- paste(features, collapse = " + ")
feature_string
locations <- c("CamdenTown", "EustonTap", "MarchmontGarden", "MonumentoGaribaldi", "PancrasLock", "RegentsParkFields", "RegentsParkJapan", "RussellSq", "SanMarco", "StPaulsCross", "StPaulsRow", "TateModern", "TorringtonSq")
data <- data %>%
filter(LocationID %in% locations)
print("Full data table has dimensions: ")
print(dim(data))
kable(print(head(data)))
data <- data %>% mutate_at(vars(GroupID, LocationID, Lockdown), funs(as.factor))
data <- data %>% mutate_at(vars(c("ISOPleasant", "ISOEventful", "Traffic", "Human", "Natural", features)), funs(as.numeric))
kable(head(data))
prelockdownData <- data %>% filter(Lockdown == 1)
lockdownData <- data %>% filter(Lockdown == 2)
prelockdownData <- drop_na(prelockdownData)
prelockdownData[c(features)] <- scale(prelockdownData[c(features)])
# Train-test split
library(groupdata2)
set.seed(42)
parts = partition(prelockdownData, p=0.2, cat_col="LocationID")
train = parts[[2]]
test = parts[[1]]
kable(summary(train))
kable(summary(test))
model.building <- function(target, features, train, test, grp="LocationID", exclude.features = NULL, print.step.summ = FALSE, scale=TRUE, ...) {
if (!require("pacman")) install.packages("pacman")
pacman::p_load(lmerTest, glue, knitr, car, sjPlot, MuMIn, ggplot2, gridExtra, ModelMetrics)
# Remove the excluded features from the feature vector
if (length(exclude.features)>=1) {
features <- grep(paste0(exclude.features, collapse = "|"), features, invert=TRUE, value=TRUE)
}
features.string <- paste(features, collapse = " + ")
formula <- as.formula(glue(target, " ~ 1 + ", features.string, " + (1 + ", features.string, "|", grp, ")"))
train.data <- train
test.data <- test
if (scale) {
train.data[c(features)] <- scale(train.data[c(features)])
}
# Fit initial model and run stepwise feature selection
init.model <- lmer(formula, data=train.data)
step.model <- step(init.model, data=train.data, reduce.random=TRUE)
model <- get_model(step.model)
formula <- formula(model)
model <- lmer(formula, data=train)
if (print.step.summ) {
print(step.model$fixed)
print(step.model$random)
print(summary(model))
}
# kable(vif(model))
# print(tab_model(model, show.icc=TRUE, collapse.ci=TRUE, show.aic=TRUE))
print(plot_model(model, type="re", title=glue("Random effects - ", target), show.values=TRUE))
print(plot_model(model, show.values=TRUE))
print(r.squaredGLMM(model))
# Generating predictions and evaluating for training and test set
pred.results <- pred.plots(model, target, train.data, test.data, grp=grp)
results <- list("step.results" = step.model, "model" = model, "pred.results"= pred.results)
}
pred.plots <- function(model, target, train.data, test.data, grp="LocationID") {
if (!require("pacman")) install.packages("pacman")
pacman::p_load(knitr, ModelMetrics, gridExtra, ggplot2, glue)
train.pred <- train.data[grp]
train.pred$actual <- train.data[target][[1]]
train.pred$pred <- predict(model)
test.pred <- test.data[grp]
test.pred$actual <- test.data[target][[1]]
test.pred$pred <- predict(model, newdata=test.data)
# Calculate the normalised RMSE
range <- abs(max(train.pred$actual) - min(train.pred$actual))
train.nrmse <- rmse(train.pred$pred, train.pred$actual) / range
test.nrmse <- rmse(test.pred$pred, test.pred$actual) / range
# Plot predicted vs actual
test.title <- glue("Test Set (NRMSE=", round(test.nrmse, 3), ")", sep="")
test.plot <- ggplot(test.pred, aes(x=pred, y=actual, colour=LocationID)) +
geom_point() +
geom_abline(intercept=0, slope=1) +
labs(x = 'Predicted Values', y='Actual Values', title=test.title)+
coord_fixed() +
theme(legend.position="none")
train.title <- glue("Train Set (NRMSE=", round(train.nrmse, 3), ")", sep="")
train.plot <- ggplot(train.pred, aes(x=pred, y=actual, colour=LocationID)) +
geom_point() +
geom_abline(intercept=0, slope=1) +
labs(x = 'Predicted Values', y='Actual Values', title=train.title) +
coord_fixed() +
theme(legend.position="none")
grid.arrange(train.plot, test.plot, nrow=1)
results <- list("train.pred" = train.pred, "test.pred" = test.pred)
}
Pleasant.results <- model.building(target="ISOPleasant", features = features, train.data = train, test.data = test, grp="LocationID", exclude.features = c("LAeq"))
Pleasant.results <- model.building(target="ISOPleasant", features = features, train = train, test = test, grp="LocationID", exclude.features = c("LAeq"))
Eventful.results <- model.building(target="ISOEventful", features = features, train = train, test = test, grp="LocationID")
Eventful.results <- model.building(target="ISOEventful", features = features, train = train, test = test, grp="LocationID")
sjPlot::tab_model(Pleasant.results$model, Eventful.results$model, std.est='std')
Pleasant.results$model
summary(Pleasant.results$model)
plot_model(Pleasant.results$model)
plot_model(Pleasant.results$model, std.est='std')
plot_model(Pleasant.results$model, std.est='std2')
tab_model(Pleasant.results$model)
tab_model(Pleasant.results$model, std.est='std')
knitr::opts_chunk$set(echo = TRUE)
init_features <- c("Loudness_N5(soneGF)", "Sharpness_S(acum)", "Rough_HM_R(asper)", "I_HM_I(iu)", "FS_(vacil)", "LAeq_L(A)(dB(SPL))", "LA10_LA90(dB(SPL))", "LCeq_LAeq(dB(SPL))", "SIL3_Avg,arith(dB(SPL))")
init_feature_string <- paste(init_features, collapse = " + ")
init_feature_string
library(glue)
library(tidyr)
library(here)
library(knitr)
library(dplyr)
library(readxl)
data <- read_excel(here("data", "2021-05-05", "SSID Europe Database V1.0.xlsx"), sheet = "Master Merge")
data <- as_tibble(data)
data <- data[c("GroupID", "LocationID", "Lockdown", "ISOPleasant", "ISOEventful", "Human", "Traffic", "Natural", init_features)]
data <- rename(data, "N5" = "Loudness_N5(soneGF)")
data <- rename(data, "S" = "Sharpness_S(acum)")
data <- rename(data, "R" = "Rough_HM_R(asper)")
data <- rename(data, "I" = "I_HM_I(iu)")
data <- rename(data, "FS" = "FS_(vacil)")
data <- rename(data, "LAeq" = "LAeq_L(A)(dB(SPL))")
data <- rename(data, "LA10_LA90" = "LA10_LA90(dB(SPL))")
data <- rename(data, "LCeq_LAeq" = "LCeq_LAeq(dB(SPL))")
data <- rename(data, "SIL3" = "SIL3_Avg,arith(dB(SPL))")
features <- c("N5", "S", "R", "I", "FS", "LAeq", "LA10_LA90", "LCeq_LAeq", "SIL3")
feature_string <- paste(features, collapse = " + ")
feature_string
locations <- c("CamdenTown", "EustonTap", "MarchmontGarden", "MonumentoGaribaldi", "PancrasLock", "RegentsParkFields", "RegentsParkJapan", "RussellSq", "SanMarco", "StPaulsCross", "StPaulsRow", "TateModern", "TorringtonSq")
data <- data %>%
filter(LocationID %in% locations)
print("Full data table has dimensions: ")
print(dim(data))
kable(print(head(data)))
data <- data %>% mutate_at(vars(GroupID, LocationID, Lockdown), funs(as.factor))
data <- data %>% mutate_at(vars(c("ISOPleasant", "ISOEventful", "Traffic", "Human", "Natural", features)), funs(as.numeric))
kable(head(data))
prelockdownData <- data %>% filter(Lockdown == 1)
lockdownData <- data %>% filter(Lockdown == 2)
prelockdownData <- drop_na(prelockdownData)
# prelockdownData[c(features)] <- scale(prelockdownData[c(features)])
# Train-test split
library(groupdata2)
set.seed(42)
parts = partition(prelockdownData, p=0.2, cat_col="LocationID")
train = parts[[2]]
test = parts[[1]]
kable(summary(train))
kable(summary(test))
model.building <- function(target, features, train, test, grp="LocationID", exclude.features = NULL, print.step.summ = FALSE, scale=TRUE, ...) {
if (!require("pacman")) install.packages("pacman")
pacman::p_load(lmerTest, glue, knitr, car, sjPlot, MuMIn, ggplot2, gridExtra, ModelMetrics)
# Remove the excluded features from the feature vector
if (length(exclude.features)>=1) {
features <- grep(paste0(exclude.features, collapse = "|"), features, invert=TRUE, value=TRUE)
}
features.string <- paste(features, collapse = " + ")
formula <- as.formula(glue(target, " ~ 1 + ", features.string, " + (1 + ", features.string, "|", grp, ")"))
train.data <- train
test.data <- test
if (scale) {
train.data[c(features)] <- scale(train.data[c(features)])
}
# Fit initial model and run stepwise feature selection
init.model <- lmer(formula, data=train.data)
step.model <- step(init.model, data=train.data, reduce.random=TRUE)
model <- get_model(step.model)
formula <- formula(model)
model <- lmer(formula, data=train)
if (print.step.summ) {
print(step.model$fixed)
print(step.model$random)
print(summary(model))
}
# kable(vif(model))
# print(tab_model(model, show.icc=TRUE, collapse.ci=TRUE, show.aic=TRUE))
print(plot_model(model, type="re", title=glue("Random effects - ", target), show.values=TRUE))
print(plot_model(model, show.values=TRUE))
print(r.squaredGLMM(model))
# Generating predictions and evaluating for training and test set
pred.results <- pred.plots(model, target, train.data, test.data, grp=grp)
results <- list("step.results" = step.model, "model" = model, "pred.results"= pred.results)
}
pred.plots <- function(model, target, train.data, test.data, grp="LocationID") {
if (!require("pacman")) install.packages("pacman")
pacman::p_load(knitr, ModelMetrics, gridExtra, ggplot2, glue)
train.pred <- train.data[grp]
train.pred$actual <- train.data[target][[1]]
train.pred$pred <- predict(model)
test.pred <- test.data[grp]
test.pred$actual <- test.data[target][[1]]
test.pred$pred <- predict(model, newdata=test.data)
# Calculate the normalised RMSE
range <- abs(max(train.pred$actual) - min(train.pred$actual))
train.nrmse <- rmse(train.pred$pred, train.pred$actual) / range
test.nrmse <- rmse(test.pred$pred, test.pred$actual) / range
# Plot predicted vs actual
test.title <- glue("Test Set (NRMSE=", round(test.nrmse, 3), ")", sep="")
test.plot <- ggplot(test.pred, aes(x=pred, y=actual, colour=LocationID)) +
geom_point() +
geom_abline(intercept=0, slope=1) +
labs(x = 'Predicted Values', y='Actual Values', title=test.title)+
coord_fixed() +
theme(legend.position="none")
train.title <- glue("Train Set (NRMSE=", round(train.nrmse, 3), ")", sep="")
train.plot <- ggplot(train.pred, aes(x=pred, y=actual, colour=LocationID)) +
geom_point() +
geom_abline(intercept=0, slope=1) +
labs(x = 'Predicted Values', y='Actual Values', title=train.title) +
coord_fixed() +
theme(legend.position="none")
grid.arrange(train.plot, test.plot, nrow=1)
results <- list("train.pred" = train.pred, "test.pred" = test.pred)
}
Pleasant.results <- model.building(target="ISOPleasant", features = features, train = train, test = test, grp="LocationID", exclude.features = c("LAeq"))
Eventful.results <- model.building(target="ISOEventful", features = features, train = train, test = test, grp="LocationID")
sjPlot::tab_model(Pleasant.results$model, Eventful.results$model, std.est='std')
sjPlot::tab_model(Pleasant.results$model, Eventful.results$model)
sjPlot::tab_model(Pleasant.results$model, Eventful.results$model, std.est='std2')
sjPlot::tab_model(Pleasant.results$model, Eventful.results$model, std.est='std')
Pleasant.results$model
formula(Pleasant.results$model)
formula(Pleasant.results$step.results)
Pleasant.results$step.results
formula(get_model(Pleasant.results$step.results))
string(formula(get_model(Pleasant.results$step.results)))
str(formula(get_model(Pleasant.results$step.results)))
fixef(Pleasant.results$model)
fixef(Pleasant.results$model)[0]
fixef(Pleasant.results$model)[1]
fixef(Pleasant.results$model)[2]
fixef(Pleasant.results$model)[2][1]
fixef(Pleasant.results$model)[2][[1]]
fixef(Pleasant.results$model)[2][[2]]
fixef(Pleasant.results$model)[2][[0]]
nlformula(get_model(Pleasant.results$step.results))
nlformula(Pleasant.results$model)
plot(Pleasant.results$model)
pvalues(Pleasant.results$model)
ranef(Pleasant.results$model)
getME(Pleasant.results$model, "y")
getME(Pleasant.results$model, "theta")
getME(Pleasant.results$model, "l_i")
getME(Pleasant.results$model, "cnms")
library(merTools)
install.packages("merTools")
library(merTools)
modelInfo(Pleasant.results$model)
RMSE.merMod(Pleasant.results$model)
shinyMer(Pleasant.results$model)
formula(Pleasant.results$model)
formula(get_model(Pleasant.results$step.results))
model <- lmer(ISOPleasant ~ N5 + (R + LA10_LA90|LocationID), data=train)
tab_model(model)
tab_model(model, std.est="est")
model <- lme4::lmer(ISOPleasant ~ N5 + (R + LA10_LA90|LocationID), data=train)
tab_model(model, std.est="est")
Pleasant.results <- model.building(target="ISOPleasant", features = features, train = train, test = test, grp="LocationID")
Pleasant.results$model
car::vif(Pleasant.results$model)
Pleasant.results <- model.building(target="ISOPleasant", features = features, train = train, test = test, grp="LocationID", exclude.features = c("SIL3"))
Pleasant.results$model
Pleasant.results <- model.building(target="ISOPleasant", features = features, train = train, test = test, grp="LocationID", exclude.features = c("LAeq"))
Eventful.results <- model.building(target="ISOEventful", features = features, train = train, test = test, grp="LocationID")
sjPlot::tab_model(Pleasant.results$model, Eventful.results$model, std.est='std')
sjPlot::tab_model(Pleasant.results$model, Eventful.results$model)
sjPlot::plot_models(Pleasant.results$model, Eventful.results$model, std.est='std')
model.building <- function(target, features, train, test, grp="LocationID", exclude.features = NULL, print.step.summ = FALSE, scale=TRUE, ...) {
if (!require("pacman")) install.packages("pacman")
pacman::p_load(lmerTest, glue, knitr, car, sjPlot, MuMIn, ggplot2, gridExtra, ModelMetrics)
# Remove the excluded features from the feature vector
if (length(exclude.features)>=1) {
features <- grep(paste0(exclude.features, collapse = "|"), features, invert=TRUE, value=TRUE)
}
features.string <- paste(features, collapse = " + ")
formula <- as.formula(glue(target, " ~ 1 + ", features.string, " + (1 + ", features.string, "|", grp, ")"))
train.data <- train
test.data <- test
if (scale) {
train.data[c(features)] <- scale(train.data[c(features)])
}
# Fit initial model and run stepwise feature selection
init.model <- lmer(formula, data=train.data)
step.model <- step(init.model, data=train.data, reduce.random=TRUE)
scaled.model <- get_model(step.model)
formula <- formula(scaled.model)
model <- lmer(formula, data=train)
if (print.step.summ) {
print(step.model$fixed)
print(step.model$random)
print(summary(model))
}
# kable(vif(model))
# print(tab_model(model, show.icc=TRUE, collapse.ci=TRUE, show.aic=TRUE))
print(plot_model(model, type="re", title=glue("Random effects - ", target), show.values=TRUE))
print(plot_model(model, show.values=TRUE))
print(r.squaredGLMM(model))
# Generating predictions and evaluating for training and test set
pred.results <- pred.plots(model, target, train.data, test.data, grp=grp)
results <- list("step.results" = step.model, "model" = model, "pred.results"= pred.results, "scaled.model"=scaled.model)
}
pred.plots <- function(model, target, train.data, test.data, grp="LocationID") {
if (!require("pacman")) install.packages("pacman")
pacman::p_load(knitr, ModelMetrics, gridExtra, ggplot2, glue)
train.pred <- train.data[grp]
train.pred$actual <- train.data[target][[1]]
train.pred$pred <- predict(model)
test.pred <- test.data[grp]
test.pred$actual <- test.data[target][[1]]
test.pred$pred <- predict(model, newdata=test.data)
# Calculate the normalised RMSE
range <- abs(max(train.pred$actual) - min(train.pred$actual))
train.nrmse <- rmse(train.pred$pred, train.pred$actual) / range
test.nrmse <- rmse(test.pred$pred, test.pred$actual) / range
# Plot predicted vs actual
test.title <- glue("Test Set (NRMSE=", round(test.nrmse, 3), ")", sep="")
test.plot <- ggplot(test.pred, aes(x=pred, y=actual, colour=LocationID)) +
geom_point() +
geom_abline(intercept=0, slope=1) +
labs(x = 'Predicted Values', y='Actual Values', title=test.title)+
coord_fixed() +
theme(legend.position="none")
train.title <- glue("Train Set (NRMSE=", round(train.nrmse, 3), ")", sep="")
train.plot <- ggplot(train.pred, aes(x=pred, y=actual, colour=LocationID)) +
geom_point() +
geom_abline(intercept=0, slope=1) +
labs(x = 'Predicted Values', y='Actual Values', title=train.title) +
coord_fixed() +
theme(legend.position="none")
grid.arrange(train.plot, test.plot, nrow=1)
results <- list("train.pred" = train.pred, "test.pred" = test.pred)
}
Pleasant.results <- model.building(target="ISOPleasant", features = features, train = train, test = test, grp="LocationID", exclude.features = c("LAeq"))
Eventful.results <- model.building(target="ISOEventful", features = features, train = train, test = test, grp="LocationID")
sjPlot::tab_model(Pleasant.results$model, Eventful.results$model)
sjPlot::plot_models(Pleasant.results$model, Eventful.results$model, std.est='std')
sjPlot::tab_model(Pleasant.results$scaled.model, Eventful.results$scaled.model)
?plot_models
sjPlot::tab_model(Pleasant.results$model, Eventful.results$model)
sjPlot::tab_model(Pleasant.results$scaled.model, Eventful.results$scaled.model)
sjPlot::plot_models(Pleasant.results$model, Eventful.results$model, std.est='std', show.values = TRUE)
sjPlot::plot_models(Pleasant.results$model, Eventful.results$model, type='re', std.est='std', show.values = TRUE)
sjPlot::tab_model(Pleasant.results$model, Eventful.results$model)
sjPlot::tab_model(Pleasant.results$scaled.model, Eventful.results$scaled.model)
sjPlot::plot_models(Pleasant.results$model, Eventful.results$model, std.est='std', show.values = TRUE)
sjPlot::tab_model(Pleasant.results$model, Eventful.results$model)
sjPlot::tab_model(Pleasant.results$scaled.model, Eventful.results$scaled.model)
sjPlot::plot_models(Pleasant.results$scaled.model, Eventful.results$scaled.model, std.est='std', show.values = TRUE)
